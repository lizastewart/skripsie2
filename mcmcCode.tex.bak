\chapter{Relevant code segments} \label{codeapp}
Below are the relevant code segments taken from the MATLAB code that was used to generate the final samples used for analysis.

\section*{Prior function}
Determines the probability of $x$ assuming a normal probability over the prior values.
\begin{lstlisting}
function q_val = prior_pdf(x_values,sigmaMU)

 global mu_values
 q_val = -0.5*((x_values - mu_values)*(x_values - mu_values)')/(sigmaMU^2);

end

\end{lstlisting}
\section*{Likelihood Function}

\begin{lstlisting}
function likelihood_pi = likelihood_func(kinput,sigmaT)

% Global variables: physical constants
global_const;
% Global variables: material properties
global_prop
% Global variables: time integration values
global_time;
% Global variables: mesh geometry
global_mesh;
% Global variables of measured temperatures
global_measuredtemp;

udepths = model_kinput(kinput);
depths_measured = [depth1;depth2;depth3;depth4;depth5;depth6;depth7];
% Where depths measure is the actual measured temperature data from the experiment and udepths is the temperature at the same points generated by the model using the new k-values.

tempmat = depths_measured - udepths;
likelihood_pi = tempmat(:)'*tempmat(:)/(-2*sigmaT^2);

end

\end{lstlisting}
\section*{Adapted model function}
Model adapted to a function as explained in Section \ref{adapmodsec}. Based on source code from Prof. N de Koker.
\begin{lstlisting}
function udepths = model_kinput(kinput)

global_time;
global_mesh;
global_const;
global_prop;

kpine = kinput;

% Print current number of elements and current sample k-values 
kpine(2,:)
fprintf("%d \n",nels);

% Calculate boundary conditions
[isofc, isofcdot] = isofirecurve(tvec);
%isofc(tvec>1000) = 20;   % check cooling effect
%isofcdot(tvec>1000) = 0;
atmtemp = tvec*0 + 20;  % Celsius
atmtdot = tvec*0;

% Set up initial conditions
unode(:,1) = xnp*0 + atmtemp(1);
unode(1,1) = isofc(1);
vnode(:,1) = xnp*0 + atmtdot(1);
vnode(1,1) = isofcdot(1);%time derivatives

% Iterate: calculate temperature profile
for i = 2:length(tvec)
    % Set up Dirichlet
    ddir = zeros(nnp,1);
    vdir = zeros(nnp,1);
    ddir(1) = isofc(i);
    vdir(1) = isofcdot(i);
    ddir(nnp) = atmtemp(i);
    vdir(nnp) = atmtdot(i);
    
    % Assemble global matrices
    Kmat0 = glomatK(unode(:,i-1), ddir);
    Mmat0 = glomatM(unode(:,i-1), ddir);
    Fvec0 = glovecF(unode(:,i-1), ddir);
    
    % Account for Dirichlet
    Fdir = Kmat0*ddir + Mmat0*vdir;
    Fvec0 = Fvec0 - Fdir;
    Kmat = Kmat0(2:end-1, 2:end-1);
    Mmat = Mmat0(2:end-1, 2:end-1);
    Fvec = Fvec0(2:end-1);
    
    % Solve for d and ddot in this step
    [unode(2:end-1,i), vnode(2:end-1,i)] = dvnext( unode(2:end-1,i-1), vnode(2:end-1,i-1), Kmat, Mmat, Fvec );
    unode(:,i) = unode(:,i) + ddir;
    vnode(:,i) = vnode(:,i) + vdir;
    
    clear Kmat0 Kmat Fvec0 Fvec Mmat0 Mmat;
    
end
% Isolate nodes at depth of thermocouples
count = [2 7 12 17 22 27 32];

udepth1 = unode(count(1),2:end);
udepth2 = unode(count(2),2:end);
udepth3 = unode(count(3),2:end);
udepth4 = unode(count(4),2:end);
udepth5 = unode(count(5),2:end);
udepth6 = unode(count(6),2:end);
udepth7 = unode(count(7),2:end);

udepths = [udepth1;udepth2;udepth3;udepth4;udepth5;udepth6;udepth7];

end


\end{lstlisting}
%\newpage
\section*{Function to take next step}
This function takes the current vector $\vec{x}_n$ and generates a new probable $\vec{x}_{n+1}$.
\begin{lstlisting}
function xvalue2 = takexsteps(xvalue1)
	global temps mu_values stepsize sigmastepMU sigmastepT

	locsigma = stepsize*mu_values;
	locxvalue = xvalue1;

	lnMu = log(locxvalue.^2 ./ sqrt(locsigma.^2+locxvalue.^2));
	lnSigma = sqrt(log(locsigma.^2./xvalue1.^2 + 1));

	xvalue2 = max(0, lognrnd(lnMu, lnSigma));
	xvalue2(1) = xvalue1(1);

	xvalue2(xvalue2<locsigma/20) = (mu_values(xvalue2<locsigma/20)+xvalue2(xvalue2<locsigma/20))/2;

end
\end{lstlisting}

\section*{MCMC main}
\begin{lstlisting}

rng(1e7,"twister");
num_of_runs = 5000;
global temps mu_values stepsize 
temps = [0,60,100,140, 200,350,500,800,1200];
mu_values = [0.12, 0.12, 0.12, 0.12, 0.15, 0.07, 0.09, 0.35, 1.5]; %Based on Eurocode values
stepsize = 0.05;
allMUvalues = zeros([num_of_runs,9]);
instantiate_all();

%% Random start values generate
%rand_x = abs(mu_values * 2);
%rand_x = abs(mu_values + rand_in_rangesz(-0.05,0.5,9));
rand_x = abs(mu_values.*(0.5+rand(1,9)*1.5));
rand_x(1:2) = mu_values(1:2);
rand_sigmaT = 15;  
rand_sigmaMU = 0.13; 
 
%% MCMC Instantiate
sigmaT1 = rand_sigmaT;
sigmaMU1 = rand_sigmaMU;
xvalues1 = rand_x;
alpha = 0.2;

posteriorref = posteriori_func(mu_values,sigmaT1,sigmaMU1);

tic
posterior1 = posteriori_func(xvalues1,sigmaT1,sigmaMU1);
toc

i = 1;
j = 0;
%% Itteration MCMC 
while i <= num_of_runs
    j = j + 1;
    xvalues2 = takexsteps(xvalues1);

[mu_values; xvalues1; xvalues2]

    %constant sigma
    sigmaMU2 = sigmaMU1;
    sigmaT2 = sigmaT1;
    
tic
    posterior2 = posteriori_func(xvalues2,sigmaT2,sigmaMU2);
toc
    %%Acceptance probability
    del = exp((posterior2-posterior1)/(abs(posteriorref)/50));
    q = rand;

[i,j, posterior1, posterior2, del, q]
    if (q < del)

        %Add values to stored accepted values
        allMUvalues(i,:) = xvalues2;       
        fprintf("\n Accepted %d\n\n",i);
        
        %Set accepted value as our new stepping stone
        xvalues1 = xvalues2;
        posterior1 = posterior2;
        post(i) = posterior1-posteriorref;        
        comp(i) = del;        
        count(i) = j;        
        i=i+1;
        j=0;

       figure(11)
       scatter(temps,allMUvalues(i-1,:),'black','filled');

   end
end

%% Averages
allMUvalues;
for i=1:9
    muAverage(i) = mean(allMUvalues(1:length(count),i));
    muStd(i) = std(allMUvalues(1:length(count),i));
end
\end{lstlisting}

\section*{MAP determination}
\begin{lstlisting}
global temps stepsize mu_values
temps = [0,60,100,140, 200,350,500,800,1200];
mu_values = [0.12, 0.12, 0.12, 0.12, 0.15, 0.07, 0.09, 0.35, 1.5];
x_values = mu_values;
stepsize = 0.05;
sigmaT1 = 15;
sigmaMU1 = 0.13;
instantiate_all();

fminopts = optimset('fminsearch');
fminopts.TolX = 0.0009;
fminopts.MaxFunEvals = 1000;
fminopts.MaxIter = 1000;
lowBound= [0.000, 0.000, 0.000, 0.000, 0.000, 0.0000, 0.0000, 0.00, 0.1];
upBound = [0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 20];

fun = @(x_values) -1*posteriori_func(x_values,sigmaT1,sigmaMU1);
[mu_map,fval] = fminsearchbnd(fun, x_values,lowBound,upBound,fminopts);
\end{lstlisting}

