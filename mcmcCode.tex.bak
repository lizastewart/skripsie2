\chapter{Relevant code segments} \label{codeapp}
Below are the relevant code segments taken from the Matlab code that was used to generate the final samples used for analysis.

\section*{Prior function}
Determines the probability of $x$ assuming a (NORMAL) probability over the prior values.
\begin{lstlisting}
function q_val = prior_pdf(x_values,sigmaMU)

 global mu_values
 q_val = -0.5*((x_values - mu_values)*(x_values - mu_values)')/(sigmaMU^2);

end

\end{lstlisting}
\section*{Likelihood Function}

\begin{lstlisting}
function likelihood_pi = likelihood_func(kinput,sigmaT)

% Global variables: physical constants
global_const;
% Global variables: material properties
global_prop
% Global variables: time integration values
global_time;
% Global variables: mesh geometry
global_mesh;
% Global variables of measured temperatures
global_measuredtemp;

udepths = model_kinput(kinput);
depths_measured = [depth1;depth2;depth3;depth4;depth5;depth6;depth7];
%Where depths measure is the actual measured temperature data from the experiment and udepths is the temperature at the same points generated by the model using the new k-values.

tempmat = depths_measured - udepths;
likelihood_pi = tempmat(:)'*tempmat(:)/(-2*sigmaT^2);

end

\end{lstlisting}

%\newpage
\section*{Function to take next step}
This function takes the current $x$-vector and generates a new probable $x$-vector.
\begin{lstlisting}
function xvalue2 = takexsteps(xvalue1)
	global temps mu_values stepsize sigmastepMU sigmastepT

	locsigma = stepsize*mu_values;
	locxvalue = xvalue1 ;;

	lnMu = log(locxvalue.^2 ./ sqrt(locsigma.^2+locxvalue.^2));
	lnSigma = sqrt(log(locsigma.^2./xvalue1.^2 + 1));

	xvalue2 = max(0, lognrnd(lnMu, lnSigma));
	xvalue2(1) = xvalue1(1);

	xvalue2(xvalue2<locsigma/20) = (mu_values(xvalue2<locsigma/20)+xvalue2(xvalue2<locsigma/20))/2;

end
\end{lstlisting}

\section*{MAP determination}
\begin{lstlisting}
global temps stepsize mu_values
temps = [0,60,100,140, 200,350,500,800,1200];
mu_values = [0.12, 0.12, 0.12, 0.12, 0.15, 0.07, 0.09, 0.35, 1.5];
x_values = mu_values;
stepsize = 0.05;
sigmaT1 = 15;
sigmaMU1 = 0.13;
instantiate_all();

fminopts = optimset('fminsearch');
fminopts.TolX = 0.0009;
fminopts.MaxFunEvals = 1000;
fminopts.MaxIter = 1000;
lowBound= [0.000, 0.000, 0.000, 0.000, 0.000, 0.0000, 0.0000, 0.00, 0.1];
upBound = [0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 20];
%fminopts.AlwaysHonorConstraints =;
% fminopts.PlotFcns = 'optimfplotval';
fun = @(x_values) -1*posteriori_func(x_values,sigmaT1,sigmaMU1);
[mu_map,fval] = fminsearchbnd(fun, x_values,lowBound,upBound,fminopts);
\end{lstlisting}